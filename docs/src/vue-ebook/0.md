# Sự xuất hiện của các framework front-end

## Sự phát triển nhanh chóng của front-end

Nếu bạn cũng từng trải qua thời kỳ “jQuery một phát ăn luôn”, có lẽ bạn sẽ ngạc nhiên rằng chỉ trong vài năm ngắn ngủi, frontend đã trải qua biết bao thay đổi. Thời xưa, frontend phần lớn đại diện cho việc cắt giao diện (cut layout) và tái cấu trúc (refactor), chú trọng vào kiểu dáng trang (page styling) mà xem nhẹ logic.

Đó là thời kỳ node.js vừa xuất hiện và còn chưa ổn định, frontend thường phải ghép các template JSP, template PHP, công việc chủ yếu xoay quanh việc điều chỉnh tương thích trình duyệt (browser compatibility). Vì vậy, sự ra đời của jQuery, với phong cách lập trình chain call (gọi liên chuỗi) khiến code trở nên mượt mà như mây trôi nước chảy, đồng thời cung cấp ajax cho các yêu cầu bất đồng bộ (asynchronous request) cực kỳ dễ dùng, cùng với bộ chọn phần tử (element selector) Sizzle engine siêu tiện lợi. Những tiện ích mà jQuery mang lại gần như đáp ứng toàn bộ nhu cầu công việc của frontend lúc bấy giờ, nên nói “jQuery một phát ăn luôn” cũng không phải là không có lý.

Chắc hẳn đây cũng là ấn tượng mà các developer từng bị ép viết bộ ba HTML/CSS/Javascript (còn gọi là “tam kiếm khách”) ngày đó giữ lại về frontend: chỉ cần jQuery là đủ. Dĩ nhiên, không thể phủ nhận jQuery là một thư viện cực kỳ xuất sắc, nhưng với sự phát triển của node.js, sự hoàn thiện của quản lý gói npm, cộng thêm cộng đồng mã nguồn mở (open-source community) sôi nổi, frontend đã nhận được sự hỗ trợ từ hàng triệu developer. Từ phát triển giao diện (page development) đến phát triển thư viện công cụ (tool library), phát triển framework, phát triển script, cho đến phát triển phía server (server-side development), Javascript đơn luồng (single-threaded) đang không ngừng tự đổi mới, từ đó mở rộng lĩnh vực liên tục, hình thành nên frontend mà bạn thấy ngày nay – một frontend được trao quyền năng (empowered frontend).

### Kỹ thuật Front-end

Trong mã code của chúng ta, chúng ta sẽ sử dụng rất nhiều tài nguyên: hình ảnh, kiểu dáng (styles), mã nguồn (code), và đủ loại gói phụ thuộc (dependency packages). Khi đóng gói (build), làm thế nào để thực hiện chia nhỏ theo nhu cầu (on-demand chunking), xử lý quan hệ phụ thuộc (dependency resolution), không bao gồm các file hoặc nội dung thừa thãi, đồng thời cung cấp cả môi trường phát triển (development environment) và môi trường sản xuất (production environment), bao gồm khả năng tự động cập nhật lên trình duyệt khi debug cục bộ (local debugging) – tất cả những điều này đều được tích hợp bởi các công cụ engineering (công cụ hóa). Hiện nay, những công cụ như vậy thường được thể hiện qua gulp, webpack.

Để thực hiện engineering, phát triển frontend hầu như không thể thiếu package manager npm của node.js. Chẳng hạn, frontend thường sử dụng npm để dựng local development server hay biên dịch và đóng gói mã frontend (compile and bundle frontend code). Trong quá trình phát triển frontend, lệnh npm install thường được dùng để cài đặt các phụ thuộc cần thiết.

Đồng thời, chúng ta có thể kết hợp khả năng Tree-shaking, trong quá trình build cục bộ, loại bỏ những phần không dùng đến trong các gói phụ thuộc của người khác, từ đó giảm kích thước gói mã (code bundle size).

Các công cụ quản lý phụ thuộc (dependency management tools), công cụ tự động hóa (automation tools), công cụ chuẩn hóa mã (code linting tools), công cụ kiểm thử (testing tools), v.v., với sự xuất hiện không ngừng của các công cụ mới đã thúc đẩy nhanh chóng tiến trình engineering của frontend. Các framework khác nhau cũng đã tung ra các scaffolding tool (công cụ giàn giáo), giúp bạn nhanh chóng tạo mã ví dụ (sample code), dựng môi trường cục bộ (local environment), hoặc cập nhật phiên bản phụ thuộc, tránh việc mỗi developer phải tự điều chỉnh môi trường phát triển, logic đóng gói (bundling logic), và các cấu hình khác.

Đến đây, developer có thể tập trung vào phát triển nghiệp vụ (business development), không còn phải tốn nhiều thời gian xử lý những việc lặp đi lặp lại và kém hiệu quả, từ đó nâng cao hiệu suất phát triển lên một tầm cao mới.

## Sự xuất hiện của các framework front-end

Ban đầu, AngularJS bắt đầu chiếm lĩnh một vị trí quan trọng, sau đó React vượt lên mạnh mẽ. Với sự nâng cấp mang tính bước ngoặt của Angular, Vue đã kết hợp được các ưu điểm của nhiều framework khác nhau, cùng với tài liệu hướng dẫn cực kỳ dễ tiếp cận, thành công trở thành một “chú ngựa ô” trong lĩnh vực này.

Vậy những framework này đã làm được gì? Tại sao đến nay hầu như mọi dự án frontend đều không thể tách rời việc phát triển bằng framework? Trước tiên, chúng ta vẫn phải bắt đầu từ trình duyệt.

### Trình duyệt render trang như thế nào

Chúng ta biết rằng trong mã nguồn của một trang web, chủ yếu bao gồm ba khối nội dung lớn: HTML, CSS, và Javascript. Vậy trình duyệt phân tích (parse) và tải (load) những nội dung này ra sao?

Trong một quá trình render trang của trình duyệt, nó sẽ phân tích ba loại file:

Phân tích HTML/SVG/XHTML sẽ tạo ra một cây cấu trúc DOM (DOM structure tree).
Phân tích CSS sẽ tạo ra một cây quy tắc CSS (CSS rule tree).
Phân tích JS, có thể sử dụng DOM API và CSS API để thao tác trên cây cấu trúc DOM và cây quy tắc CSS.
Cây quy tắc CSS kết hợp với cây cấu trúc DOM, cuối cùng tạo ra một Render tree (cây kết xuất) – tức là trang web được trình bày cuối cùng. Ví dụ, trong đó sẽ loại bỏ các nút DOM (DOM nodes) trong cây cấu trúc DOM khớp với thuộc tính display:none trong CSS. Nói chung, quá trình trình duyệt vẽ (paint) trang bao gồm:

(1) Tính toán cây quy tắc CSS.

(2) Tạo Render tree.

(3) Tính toán kích thước (size), vị trí (position), và z-index của các nút.

(4) Vẽ (paint).

Do hạn chế về độ dài, ở đây tôi không đi sâu thêm, nếu bạn quan tâm có thể đọc kỹ bài viết [《How browsers work》](http://taligarsiel.com/Projects/howbrowserswork1.htm).

### Cập nhật cục bộ trang


Nhìn chung, khi trình duyệt đã tạo ra Render tree cuối cùng, trang web cũng đã được render xong, có vẻ như trình duyệt đã hoàn thành nhiệm vụ của nó. Nhưng thực tế, các trang web của chúng ta không chỉ đơn thuần là trang tĩnh (static page), mà còn bao gồm các thao tác sự kiện như nhấp chuột (click), kéo thả (drag), cũng như các yêu cầu giao tiếp API (interface request) và render dữ liệu lên trang – những logic tương tác động (dynamic interaction). Lúc này, chúng ta cần cập nhật thông tin trên trang.

Trong mã nguồn nghiệp vụ (business code) của chúng ta, tình huống sẽ phức tạp hơn nhiều. Ngoài việc chèn nội dung, còn có cập nhật nội dung, xóa nút phần tử (element node), v.v. Dù là trường hợp nào, hiện nay frontend thường áp dụng hai cách chính:

(1) String template (Mẫu chuỗi): Sử dụng cách nối chuỗi để tạo ra DOM string, sau đó chèn trực tiếp vào trang bằng innerHTML().

(2) Node template (Mẫu nút): Sử dụng các phương thức như createElement(), appendChild(), textContent, v.v., để chèn DOM node một cách động.

Người làm code thì đương nhiên phải dùng code để nói chuyện rồi! Giả sử trong trang có một phần tử <div id="div"></div>, và chúng ta cần chèn nội dung như <p>Hello<a>test</a></p>:
```js
var div = document.getElementById("div");

/** 1. String template **/ 
div.innerHTML = "<p>Hello<a>test</a></p>";

/** 2. Node template **/ 
const p = document.createElement("p"); 
p.textContent = "Hello"; 
const a = document.createElement("a"); 
a.textContent = "test"; 
p.appendChild(a); 
div.appendChild(p);
```
Tất nhiên, thế giới này không phải lúc nào cũng chỉ có trắng hoặc đen
Trong ứng dụng thực tế, có thể cả hai cách (string template và node template) đều được sử dụng cùng lúc, thậm chí đôi khi còn xen kẽ nhau. Đồng thời, khi chúng ta sử dụng DOM API và CSS API, thường sẽ kích hoạt hai loại thao tác của trình duyệt: Repaint (vẽ lại) và Reflow (tái sắp xếp):

Repaint: Phần nào đó của trang được vẽ lại, thường không liên quan đến thay đổi kích thước, ví dụ như thay đổi màu sắc.
Reflow: Có nghĩa là các nút (nodes) cần được tính toán lại và vẽ lại, thường xảy ra khi có thay đổi về kích thước.
Trong quá trình Reflow, trình duyệt sẽ làm cho phần bị ảnh hưởng trong Render tree trở nên không hợp lệ (invalidate), sau đó tái cấu trúc lại phần Render tree này. Sau khi hoàn thành Reflow, trình duyệt sẽ vẽ lại (repaint) các phần bị ảnh hưởng lên màn hình.

Chi phí của Reflow liên quan đến số lượng nút (nodes) trong Render tree cần được xây dựng lại. Vì vậy, việc sử dụng innerHTML() có thể dẫn đến nhiều chi phí (overhead) hơn.

### Các framework frontend đã làm gì

Tại sao các framework frontend lại trở nên quan trọng đến vậy? Hãy cùng xem trước khi có framework, chúng ta đã tương tác với người dùng như thế nào. Lấy ví dụ phổ biến về việc gửi một biểu mẫu (form submission) làm minh họa:

#### (1) Viết các trang tĩnh.
```html
<form> 
	Name: 
	<p id="name-value"></p> 
	<input type="text" name="name" id="name-input" /> 
	Email: 
	<p id="email-value"></p> 
	<input type="email" name="email" id="email-input" /> 
	<input type="submit" /> 
</form>
```

#### (2) Gán sự kiện tương ứng với các phần tử tương ứng.

Ví dụ, để gán một sự kiện input cho ô nhập liệu:
```js
var nameInputEl = document.getElementById("name-input"); 
var emailInputEl = document.getElementById("email-input"); 
// Lắng nghe sự kiện nhập, lúc này hàm updateValue chưa được định nghĩa
nameInputEl.addEventListener("input", updateNameValue);
emailInputEl.addEventListener("input", updateEmailValue);
```

#### (3) Khi sự kiện được kích hoạt, cập nhật nội dung trang.
```js
var nameValueEl = document.getElementById("name-value"); 
var emailValueEl = document.getElementById("email-value"); 
// Định nghĩa hàm updateValue, dùng để cập nhật nội dung trang 
function updateNameValue(e) { 
	nameValueEl.innerText = e.srcElement.value; 
} 

function updateEmailValue(e) { 
	emailValueEl.innerText = e.srcElement.value; 
}
```

Đoạn trên là ví dụ đơn giản nhất. Kết hợp với cách cập nhật trang đã nói trước đó, nếu trang của chúng ta có nhiều nội dung cần cập nhật, chỉ riêng việc nối chuỗi (string concatenation) thôi cũng có thể khiến chúng ta phải viết một đống code. Trong ví dụ dưới đây, để không chiếm quá nhiều không gian, tôi sẽ sử dụng jQuery, nếu không thì lượng code sẽ còn nhiều hơn nữa.

Ví dụ, chúng ta thêm một thẻ (card) mới, và trong thẻ này cần điền một số nội dung:
```js
var index = 0; 
// Dùng để thêm một thẻ mới, thẻ cần điền một số nội dung 
function addCard() { 
	// Lấy một phần tử có id là the-dom 
	var body = $("#the-dom"); 
	// Từ phần tử đó lấy các phần tử có class là the-class 
	var addDom = body.find(".the-class"); 
	// Chèn một div trước phần tử the-class 
	addDom.before('<div class="col-lg-4" data-index="' + index + '"></div>'); 
	// Đồng thời lưu lại nút DOM đó, tiện cho việc cập nhật nội dung 
	var theDom = body.find('[data-index="' + index + '"]'); 
	theDom.innerHTML(`<input type="text" class="form-control question" placeholder="Your question">
				<input type="text" class="form-control option-a" placeholder="Answer 1"> 
				<input type="text" class="form-control option-b" placeholder="Answer 2">` ); 
	// Sau khi hoàn thành, tăng index lên 
	index++; 
	return theDom; 
}
```

Và khi chúng ta cần áp dụng giới hạn số ký tự cho ô nhập liệu (input):
```js
// theDom sử dụng tham chiếu đã lưu ở trên 
// Gán giá trị cho câu hỏi 
theDom 
	.on("keyup", ".question", function(ev) { 
		ev.target.value = ev.target.value.substr(0, 20); 
	}) 
	// Gán giá trị cho câu trả lời a 
	.on("keyup", ".option-a", function(ev) { 
		ev.target.value = ev.target.value.substr(0, 10); 
	}) 
	// Gán giá trị cho câu trả lời b 
	.on("keyup", ".option-b", function(ev) { 
		ev.target.value = ev.target.value.substr(0, 10); 
	});
```
Và khi chúng ta cần lấy nội dung từ một số ô nhập liệu (input):
```js
// Lấy giá trị nhập vào của thẻ 
// theDom sử dụng tham chiếu đã lưu ở trên 
function getCardValue(index) { 
	var body = $("#the-dom"); 
	var theDom = body.find('[data-index="' + index + '"]'); 
	var questionName = theDom.find(".question").val(); 
	var optionA = theDom.find(".option-a").val(); 
	var optionB = theDom.find(".option-b").val(); 
	return { 
		questionName, 
		optionA, 
		optionB 
	}; 
}
```
Và khi chúng ta sử dụng Vue, chúng ta có thể viết như thế này:  

```js
<template> 
	<div v-for="card in cards"> 
		<input type="text" class="form-control question" v-model="card.questionName" placeholder="Your question" /> 
		<input type="text" class="form-control option-a" v-model="card.optionA" placeholder="Answer 1" /> 
		<input type="text" class="form-control option-b" v-model="card.optionB" placeholder="Answer 2" /> 
	</div> 
</template>  
<script> 
export default { 
	name: "Cards", 
	data() { 
		return { 
			cards: [] 
		}; 
	}, 
	methods: { 
		// Thêm một thẻ 
		addCard() { 
			this.cards.push({ 
				questionName: "", 
				optionA: "", 
				optionB: "" 
			}); 
		}, 
		// Lấy giá trị nhập vào của thẻ 
		getCardValue(index) { 
			return this.cards[index]; 
		} 
	} 
}; 
</script>
```

Việc data binding (liên kết dữ liệu), cập nhật giao diện (interface update), lắng nghe sự kiện (event listening), v.v., đều được cung cấp cho developer theo cách đơn giản nhất, giúp hiệu suất phát triển và tính dễ bảo trì của code (code maintainability) tăng lên đáng kể. Một tính năng rất quan trọng trong các framework frontend là template engine (công cụ mẫu). Thông qua AST (Abstract Syntax Tree - Cây cú pháp trừu tượng), nó còn có thể thực hiện những việc sau:

- Loại bỏ các DOM element không hợp lệ và hỗ trợ báo lỗi trong quá trình build.
- Khi sử dụng custom component (thành phần tùy chỉnh), có thể khớp chúng một cách chính xác.
- Dễ dàng thực hiện data binding, event binding, v.v., với khả năng tự động cập nhật trang.
- Đặt nền tảng cho quá trình Virtual DOM Diff.
- HTML escaping (thoát ký tự HTML) để ngăn chặn lỗ hổng XSS (Cross-Site Scripting).

Kết hợp với frontend engineering (công cụ hóa frontend) đã đề cập trước đó, mô hình phát triển frontend đã có sự thay đổi lớn. Chúng ta hãy xem xét cụ thể framework Vue đã làm gì, làm thế nào để nhanh chóng nhập môn và sử dụng thành thạo, những cách nào có thể nâng cao hiệu suất phát triển, tránh được một số vấn đề dễ xảy ra, hoặc thậm chí là những cách viết code sáng tạo đầy đột phá – tất cả đều có thể tìm thấy trong cuốn sách này. Hy vọng các bạn sẽ thích nó.
##